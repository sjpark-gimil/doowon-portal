<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/images/favicon.ico">
    <title>Doowon Portal - Dynamic Admin Settings</title>
    <link rel="stylesheet" type="text/css" href="css/style.css" />
    <link rel="stylesheet" type="text/css" href="css/darkmode.css" />
    <link rel="stylesheet" type="text/css" href="css/table.css" />
</head>

<body>
    <div class="admin-header">
        <h1>âš™ï¸ Admin Settings</h1>
        <p>Codebeamer í•„ë“œ ë§¤í•‘ ê´€ë¦¬ ë° ì‹œìŠ¤í…œ ì„¤ì •</p>
    </div>

    <nav class="admin-nav">
        <div class="admin-nav-container">
            <div class="admin-nav-title">Codebeamer ì—°ë™ ì„¤ì •</div>
            <div class="admin-nav-actions">
                <span class="admin-username">ê´€ë¦¬ì: <%= username %></span>
                <a href="/" class="btn-admin btn-secondary">â† ë‘ì›ê³µì¡° í¬íƒˆë¡œ ëŒì•„ê°€ê¸°</a>
                <a href="/admin/logout" class="btn-admin btn-secondary">ë¡œê·¸ì•„ì›ƒ</a>
            </div>
        </div>
    </nav>

    <div class="admin-section">
        <div class="codebeamer-info">
            <h4>ğŸ”— Codebeamer ì—°ê²° ì •ë³´</h4>
            <div class="info-item">
                <span class="info-label">ì„œë²„ URL : <%= serverUrl %></span>
            </div>
            <div class="info-item">
                <span class="info-label">ì—°ê²° ìƒíƒœ : <span class="info-value" id="connectionStatus">í™•ì¸ ì¤‘...</span></span>
            </div>    
            <br>
        
            <h4>ğŸ“‹ í”„ë¡œì íŠ¸ ì„¤ì •</h4>
            <div class="field-item">
                <span class="field-label">í”„ë¡œì íŠ¸ ì„ íƒ</span>
                <select id="projectId" class="field-mapping-input" onchange="onProjectChange()">
                    <option value="">í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>
                </select>
                <button class="btn-admin btn-info" onclick="loadProjects()">í”„ë¡œì íŠ¸ ëª©ë¡ ìƒˆë¡œê³ ì¹¨</button>
            </div>
            

            <h4>ğŸ“Š í•„ë“œ ë§¤í•‘ í˜„í™©</h4>
            <div class="mapping-stats">
                <div class="stat-item">
                    <span class="status-indicator status-mapped"></span>
                    <span>ì´ ê´€ë¦¬ ì„¹ì…˜ : <strong id="totalSections">0</strong>ê°œ</span>
                </div>
                <div class="stat-item">
                    <span class="status-indicator status-pending"></span>
                    <span>ì´ í•„ë“œ : <strong id="totalFields">0</strong>ê°œ</span>
                </div>
                <div class="stat-item">
                    <span class="status-indicator status-unmapped"></span>
                    <span>í™œì„± ì„¹ì…˜:  <strong id="activeSections">0</strong>ê°œ</span>
                </div>
            </div>
       
        </div>

        <!-- ê´€ë¦¬ ì„¹ì…˜ë³„ í•„ë“œ ì„¤ì • -->
        <div id="managementSections">
            <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë  ì„¹ì…˜ë“¤ -->
        </div>

    </div>

    <script>
        let fieldConfigs = {
            'weekly-reports': [],
            'travel-reports': [],
            'hardware-management': [],
            'equipment-management': [],
            'external-training': []
        };

        let availableTrackers = [];
        let selectedTrackers = {
            'weekly-reports': '',
            'travel-reports': '',
            'hardware-management': '',
            'equipment-management': '',
            'external-training': ''
        };

        let sectionTitles = {
            'weekly-reports': { name: 'ì£¼ê°„ë³´ê³ ê´€ë¦¬', icon: 'ğŸ“Š' },
            'travel-reports': { name: 'ì¶œì¥ë³´ê³ ê´€ë¦¬', icon: 'âœˆï¸' },
            'hardware-management': { name: 'HW/SW ë²„ì „ê´€ë¦¬', icon: 'ğŸ’»' },
            'equipment-management': { name: 'ì¥ë¹„ê´€ë¦¬', icon: 'ğŸ”§' },
            'external-training': { name: 'ì™¸ë¶€êµìœ¡ê´€ë¦¬', icon: 'ğŸ“' }
        };

        // Field type configurations
        const fieldTypes = {
            string: {
                name: 'ë¬¸ìì—´',
                icon: 'ğŸ“',
                inputType: 'text',
                validation: 'text'
            },
            number: {
                name: 'ìˆ«ì',
                icon: 'ğŸ”¢',
                inputType: 'number',
                validation: 'number'
            },
            calendar: {
                name: 'ë‚ ì§œ',
                icon: 'ğŸ“…',
                inputType: 'date',
                validation: 'date'
            },
            textarea: {
                name: 'í…ìŠ¤íŠ¸ ì˜ì—­',
                icon: 'ğŸ“„',
                inputType: 'textarea',
                validation: 'text'
            },
            selector: {
                name: 'ì„ íƒ',
                icon: 'ğŸ“‹',
                inputType: 'select',
                validation: 'select'
            }
        };

        document.addEventListener('DOMContentLoaded', async function() {
            checkConnection();
            await loadSectionTitles();
            await loadFieldConfigs();
            renderManagementSections();
            updateStats();
            await loadProjects();
            await loadTrackerIds();
            
            const savedProjectId = localStorage.getItem('adminSelectedProjectId');
            if (savedProjectId) {
                const projectSelect = document.getElementById('projectId');
                projectSelect.value = savedProjectId;
                console.log('Restored saved project:', savedProjectId);
                
                await loadTrackers();
                
                setTimeout(() => {
                    const savedTrackers = JSON.parse(localStorage.getItem('adminSelectedTrackers') || '{}');
                    Object.keys(savedTrackers).forEach(section => {
                        const trackerSelect = document.getElementById(`tracker-${section}`);
                        if (trackerSelect && savedTrackers[section]) {
                            trackerSelect.value = savedTrackers[section];
                            selectedTrackers[section] = savedTrackers[section];
                            console.log(`Restored tracker for ${section}:`, savedTrackers[section]);
                        }
                    });
                    
                    const savedSection = localStorage.getItem('adminExpandedSection');
                    if (savedSection) {
                        const sectionElement = document.getElementById(`section-${savedSection}`);
                        if (sectionElement && sectionElement.classList.contains('collapsed')) {
                            toggleSection(savedSection);
                        }
                        console.log('Restored expanded section:', savedSection);
                    }
                }, 1000);
            }
        });

        // Load available projects from Codebeamer
        async function loadProjects() {
            try {
                const response = await fetch('/api/codebeamer/projects');
                const data = await response.json();
                
                const projectSelect = document.getElementById('projectId');
                projectSelect.innerHTML = '<option value="">í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>';
                
                if (data && Array.isArray(data)) {
                    data.forEach(project => {
                        const option = document.createElement('option');
                        option.value = project.id;
                        option.textContent = `${project.name} (ID: ${project.id})`;
                        if (project.description) {
                            option.textContent += ` - ${project.description}`;
                        }
                        projectSelect.appendChild(option);
                    });
                    console.log(`Loaded ${data.length} projects`);
                } else {
                    console.error('Invalid projects data:', data);
                    alert('í”„ë¡œì íŠ¸ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                console.error('Error loading projects:', error);
                alert('í”„ë¡œì íŠ¸ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // Handle project selection change
        async function onProjectChange() {
            const projectId = document.getElementById('projectId').value;
            if (projectId) {
                console.log(`Selected project ID: ${projectId}`);
                localStorage.setItem('adminSelectedProjectId', projectId);
                availableTrackers = [];
                populateTrackerSelectors();
                
                await loadTrackers();
            }
        }

        // Load available trackers from Codebeamer
        async function loadTrackers() {
            const projectId = document.getElementById('projectId').value;
            if (!projectId) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                const response = await fetch(`/api/admin/available-trackers?projectId=${projectId}`);
                const data = await response.json();
                
                if (data.success) {
                    availableTrackers = data.trackers;
                    populateTrackerSelectors();
                    // Load saved tracker IDs after populating selectors
                    await loadTrackerIds();
                    alert(`íŠ¸ë˜ì»¤ ${data.trackers.length}ê°œë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`);
                } else {
                    alert(`íŠ¸ë˜ì»¤ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ${data.error}`);
                }
            } catch (error) {
                console.error('Error loading trackers:', error);
                alert('íŠ¸ë˜ì»¤ ë¶ˆëŸ¬ì˜¤ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // Populate tracker selectors for all sections
        function populateTrackerSelectors() {
            const sections = ['weekly-reports', 'travel-reports', 'hardware-management', 'equipment-management', 'external-training'];
            
            sections.forEach(section => {
                const selector = document.getElementById(`tracker-${section}`);
                if (selector) {
                    selector.innerHTML = '<option value="">íŠ¸ë˜ì»¤ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>';
                    
                    availableTrackers.forEach(tracker => {
                        const option = document.createElement('option');
                        option.value = tracker.id;
                        option.textContent = `${tracker.name} (${tracker.id})`;
                        if (tracker.description) {
                            option.textContent += ` - ${tracker.description}`;
                        }
                        selector.appendChild(option);
                    });

                    // Restore previously selected tracker
                    if (selectedTrackers[section]) {
                        selector.value = selectedTrackers[section];
                        console.log(`Restored tracker for ${section}: ${selectedTrackers[section]}`);
                    }
                }
            });
        }

        function updateTrackerSelection(section, trackerId) {
            selectedTrackers[section] = trackerId;
            console.log(`Updated tracker for ${section}: ${trackerId}`);
            
            const savedTrackers = JSON.parse(localStorage.getItem('adminSelectedTrackers') || '{}');
            savedTrackers[section] = trackerId;
            localStorage.setItem('adminSelectedTrackers', JSON.stringify(savedTrackers));
            
            if (trackerId) {
                saveTrackerIdForSection(section, trackerId);
            }
        }

        // Save tracker ID for a section
        async function saveTrackerIdForSection(section, trackerId) {
            try {
                const response = await fetch(`/api/admin/tracker-id/${section}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ trackerId: trackerId })
                });

                const data = await response.json();
                
                if (data.success) {
                    console.log(`Tracker ID saved for ${section}: ${trackerId}`);
                    // Show success message
                    showNotification(`íŠ¸ë˜ì»¤ IDê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤: ${section} -> ${trackerId}`, 'success');
                } else {
                    console.error('Failed to save tracker ID:', data.error);
                    showNotification(`íŠ¸ë˜ì»¤ ID ì €ì¥ ì‹¤íŒ¨: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Error saving tracker ID:', error);
                showNotification(`íŠ¸ë˜ì»¤ ID ì €ì¥ ì¤‘ ì˜¤ë¥˜: ${error.message}`, 'error');
            }
        }

        // Load tracker IDs for all sections
        async function loadTrackerIds() {
            const sections = ['weekly-reports', 'travel-reports', 'hardware-management', 'equipment-management', 'external-training'];
            
            for (const section of sections) {
                try {
                    const response = await fetch(`/api/admin/tracker-id/${section}`);
                    const data = await response.json();
                    
                    if (data.success && data.trackerId) {
                        selectedTrackers[section] = data.trackerId;
                        const selector = document.getElementById(`tracker-${section}`);
                        if (selector) {
                            selector.value = data.trackerId;
                        }
                    }
                } catch (error) {
                    console.error(`Error loading tracker ID for ${section}:`, error);
                }
            }
        }

        // Show notification
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            
            // Style the notification
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 4px;
                color: white;
                font-weight: bold;
                z-index: 1000;
                max-width: 400px;
                word-wrap: break-word;
            `;
            
            // Set background color based on type
            if (type === 'success') {
                notification.style.backgroundColor = '#28a745';
            } else if (type === 'error') {
                notification.style.backgroundColor = '#dc3545';
            } else {
                notification.style.backgroundColor = '#17a2b8';
            }
            
            // Add to page
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }

        async function refreshTrackers(section) {
            await loadTrackers();
        }

        async function loadSectionTitles() {
            try {
                const response = await fetch('/api/admin/section-titles');
                const data = await response.json();
                
                if (data.success && data.sectionTitles) {
                    sectionTitles = data.sectionTitles;
                    console.log('Loaded section titles:', sectionTitles);
                }
            } catch (error) {
                console.log('Using default section titles');
            }
        }

        async function saveSectionTitles() {
            try {
                const response = await fetch('/api/admin/section-titles', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ sectionTitles: sectionTitles })
                });

                const data = await response.json();
                return data.success;
            } catch (error) {
                console.error('Error saving section titles:', error);
                return false;
            }
        }

        async function editSectionTitle(sectionKey) {
            const titleElement = document.getElementById(`section-title-${sectionKey}`);
            const currentTitle = sectionTitles[sectionKey].name;
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentTitle;
            input.className = 'section-title-input';
            input.style.fontSize = '1.2em';
            input.style.fontWeight = '600';
            input.style.padding = '4px 8px';
            input.style.border = '2px solid #007bff';
            input.style.borderRadius = '4px';
            input.style.marginLeft = '8px';
            
            input.addEventListener('keydown', async function(e) {
                if (e.key === 'Enter') {
                    const newTitle = input.value.trim();
                    if (newTitle) {
                        sectionTitles[sectionKey].name = newTitle;
                        await saveSectionTitles();
                        renderManagementSections();
                        populateTrackerSelectors();
                        updateStats();
                        showNotification('ì„¹ì…˜ ì œëª©ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
                    }
                } else if (e.key === 'Escape') {
                    renderManagementSections();
                    populateTrackerSelectors();
                }
            });
            
            input.addEventListener('blur', async function() {
                const newTitle = input.value.trim();
                if (newTitle && newTitle !== currentTitle) {
                    sectionTitles[sectionKey].name = newTitle;
                    await saveSectionTitles();
                    showNotification('ì„¹ì…˜ ì œëª©ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
                }
                renderManagementSections();
                populateTrackerSelectors();
            });
            
            titleElement.innerHTML = '';
            titleElement.appendChild(input);
            input.focus();
            input.select();
        }

        let draggedElement = null;
        let draggedFieldId = null;
        let draggedSection = null;

        function handleFieldDragStart(e, section, fieldId) {
            draggedElement = e.target;
            draggedFieldId = fieldId;
            draggedSection = section;
            e.target.style.opacity = '0.4';
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.innerHTML);
        }

        function handleFieldDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleFieldDragEnter(e) {
            if (e.target.classList.contains('field-config-row')) {
                e.target.style.borderTop = '2px solid #007bff';
            }
        }

        function handleFieldDragLeave(e) {
            if (e.target.classList.contains('field-config-row')) {
                e.target.style.borderTop = '';
            }
        }

        async function handleFieldDrop(e, section, targetFieldId) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            if (e.target.classList.contains('field-config-row')) {
                e.target.style.borderTop = '';
            }
            
            if (draggedSection !== section) {
                return false;
            }
            
            if (draggedFieldId !== targetFieldId) {
                const fields = fieldConfigs[section];
                const draggedIndex = fields.findIndex(f => f.id === draggedFieldId);
                const targetIndex = fields.findIndex(f => f.id === targetFieldId);
                
                if (draggedIndex !== -1 && targetIndex !== -1) {
                    const draggedField = fields.splice(draggedIndex, 1)[0];
                    fields.splice(targetIndex, 0, draggedField);
                    
                    await saveFieldConfigs();
                    renderManagementSections();
                    populateTrackerSelectors();
                    showNotification('í•„ë“œ ìˆœì„œê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
                }
            }
            
            return false;
        }

        function handleFieldDragEnd(e) {
            e.target.style.opacity = '1';
            
            document.querySelectorAll('.field-config-row').forEach(row => {
                row.style.borderTop = '';
            });
            
            draggedElement = null;
            draggedFieldId = null;
            draggedSection = null;
        }

        // View current tracker configuration
        async function viewTrackerConfig(section) {
            const trackerId = selectedTrackers[section];
            if (!trackerId) {
                alert('í•´ë‹¹ ì„¹ì…˜ì˜ íŠ¸ë˜ì»¤ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                const response = await fetch(`/api/admin/tracker-configuration/${trackerId}`);
                const data = await response.json();
                
                if (data.success) {
                    const config = data.configuration;
                    const configInfo = `
í˜„ì¬ íŠ¸ë˜ì»¤ ì„¤ì •:
- íŠ¸ë˜ì»¤ ID: ${trackerId}
- íŠ¸ë˜ì»¤ëª…: ${config.basicInformation?.name || 'N/A'}
- í”„ë¡œì íŠ¸ ID: ${config.basicInformation?.projectId || 'N/A'}
- í•„ë“œ ìˆ˜: ${config.fields?.length || 0}ê°œ
- í™œì„± ì›Œí¬í”Œë¡œìš°: ${config.basicInformation?.workflowIsActive ? 'Yes' : 'No'}
- ì ê¸ˆ ìƒíƒœ: ${config.basicInformation?.locked ? 'Yes' : 'No'}
- ìˆ¨ê¹€ ìƒíƒœ: ${config.basicInformation?.hidden ? 'Yes' : 'No'}
                    `;
                    alert(configInfo);
                } else {
                    alert(`íŠ¸ë˜ì»¤ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ${data.error}`);
                }
            } catch (error) {
                console.error('Error viewing tracker config:', error);
                alert('íŠ¸ë˜ì»¤ ì„¤ì • ë³´ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        async function checkConnection() {
            try {
                const response = await fetch('/api/debug/ping');
                const data = await response.json();
                const statusElement = document.getElementById('connectionStatus');
                
                if (data.success) {
                    statusElement.textContent = 'ì–‘í˜¸';
                    statusElement.style.color = '#28a745';
                } else {
                    statusElement.textContent = 'ì‹¤íŒ¨';
                    statusElement.style.color = '#dc3545';
                }
            } catch (error) {
                document.getElementById('connectionStatus').textContent = 'ì—°ê²° ì‹¤íŒ¨';
                document.getElementById('connectionStatus').style.color = '#dc3545';
            }
        }

        async function removeField(section, fieldId) {
            if (confirm('ì´ í•„ë“œë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                fieldConfigs[section] = fieldConfigs[section].filter(field => field.id !== fieldId);
                const saved = await saveFieldConfigs();
                
                if (saved) {
                    renderManagementSections();
                    populateTrackerSelectors();
                    updateStats();
                } else {
                    alert('í•„ë“œ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                }
            }
        }

        function toggleSection(section) {
            const sectionElement = document.getElementById(`section-${section}`);
            const toggleIcon = sectionElement.querySelector('.toggle-icon');
            
            sectionElement.classList.toggle('collapsed');
            
            if (sectionElement.classList.contains('collapsed')) {
                toggleIcon.textContent = 'â–¶';
                if (localStorage.getItem('adminExpandedSection') === section) {
                    localStorage.removeItem('adminExpandedSection');
                }
            } else {
                toggleIcon.textContent = 'â–¼';
                localStorage.setItem('adminExpandedSection', section);
            }
        }

        function renderManagementSections() {
            const container = document.getElementById('managementSections');
            container.innerHTML = '';
            
            const sectionKeys = ['weekly-reports', 'travel-reports', 'hardware-management', 'equipment-management', 'external-training'];
            
            sectionKeys.forEach(sectionKey => {
                const section = sectionTitles[sectionKey];
                const allFields = fieldConfigs[sectionKey];
                const fields = allFields.filter(field => !field.readonly);
                const sectionHtml = `
                    <div class="management-section" id="section-${sectionKey}">
                        <div class="management-section-header">
                        <div class="section-toggle">
                            <button class="toggle-btn" onclick="toggleSection('${sectionKey}')">
                                <span class="toggle-icon">â–¼</span>
                            </button>
                            <h3 id="section-title-${sectionKey}" style="cursor: pointer; display: inline-flex; align-items: center;" onclick="editSectionTitle('${sectionKey}')" title="í´ë¦­í•˜ì—¬ ì œëª© ìˆ˜ì •">
                                ${section.icon} ${section.name} <span style="margin-left: 8px; font-size: 0.8em; color: #666;">âœï¸</span>
                            </h3>
                            <span class="field-count">(${fields.length}ê°œ í•„ë“œ)</span>
                        </div>
                            <div class="admin-button-container">
                                <button class="btn-add-field" onclick="showAddFieldForm('${sectionKey}')" title="í•„ë“œ ì¶”ê°€">
                                    <img src="/images/plus-sign.png" alt="í•„ë“œ ì¶”ê°€" style="width: 40px; height: 40px;">
                                </button>
                                <button class="btn-admin btn-primary" onclick="saveSectionMapping('${sectionKey}')">ë§¤í•‘ ì €ì¥</button>
                                <button class="btn-admin btn-warning" onclick="testSectionMapping('${sectionKey}')">ë§¤í•‘ í…ŒìŠ¤íŠ¸</button>
                                <button class="btn-admin btn-info" onclick="viewTrackerConfig('${sectionKey}')">í˜„ì¬ ì„¤ì • ë³´ê¸°</button>
                            </div>
                        </div>
                        <div class="tracker-selection">
                            <div class="field-item">
                                <span class="field-label">ì—°ê²°ëœ íŠ¸ë˜ì»¤</span>
                                <select id="tracker-${sectionKey}" class="field-mapping-input" onchange="updateTrackerSelection('${sectionKey}', this.value)">
                                    <option value="">íŠ¸ë˜ì»¤ë¥¼ ì„ íƒí•˜ì„¸ìš” (í”„ë¡œì íŠ¸ ì„ íƒ ì‹œ ìë™ ë¡œë“œ)</option>
                                </select>
                            </div>
                        
                        </div>
                        <div class="management-section-content">
                            <div class="field-list">
                                ${fields.length === 0 ? 
                                    '<div class="empty-state"><i>ğŸ“</i><p>ë“±ë¡ëœ í•„ë“œê°€ ì—†ìŠµë‹ˆë‹¤.<br>ìƒë‹¨ì˜ "í•„ë“œ ì¶”ê°€" ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ìƒˆ í•„ë“œë¥¼ ì¶”ê°€í•˜ì„¸ìš”.</p></div>' :
                                    fields.map(field => `
                                        <div class="field-config-row" 
                                             id="field-${field.id}" 
                                             draggable="true"
                                             ondragstart="handleFieldDragStart(event, '${sectionKey}', ${field.id})"
                                             ondragover="handleFieldDragOver(event)"
                                             ondragenter="handleFieldDragEnter(event)"
                                             ondragleave="handleFieldDragLeave(event)"
                                             ondrop="handleFieldDrop(event, '${sectionKey}', ${field.id})"
                                             ondragend="handleFieldDragEnd(event)"
                                             style="cursor: move;">
                                            <div class="drag-handle" title="ë“œë˜ê·¸í•˜ì—¬ ìˆœì„œ ë³€ê²½" style="margin-right: 12px; color: #999; font-size: 1.2em;">â‹®â‹®</div>
                                            <div class="field-properties">
                                                <div class="field-prop">
                                                    <label>í•„ë“œëª…</label>
                                                    <input type="text" value="${field.name}" onchange="updateFieldProperty('${sectionKey}', ${field.id}, 'name', this.value)">
                                                </div>
                                                <div class="field-prop">
                                                    <label>íƒ€ì…</label>
                                                    <select onchange="updateFieldProperty('${sectionKey}', ${field.id}, 'type', this.value)">
                                                        <option value="string" ${field.type === 'string' ? 'selected' : ''}>ğŸ“ ë¬¸ìì—´</option>
                                                        <option value="number" ${field.type === 'number' ? 'selected' : ''}>ğŸ”¢ ìˆ«ì</option>
                                                        <option value="calendar" ${field.type === 'calendar' ? 'selected' : ''}>ğŸ“… ë‚ ì§œ</option>
                                                        <option value="textarea" ${field.type === 'textarea' ? 'selected' : ''}>ğŸ“„ í…ìŠ¤íŠ¸ ì˜ì—­</option>
                                                        <option value="selector" ${field.type === 'selector' ? 'selected' : ''}>ğŸ“‹ ì„ íƒ</option>
                                                    </select>
                                                </div>
                                                <div class="field-prop" style="display: ${field.type === 'selector' ? 'flex' : 'none'};" id="options-${field.id}">
                                                    <label>ì„ íƒ ì˜µì…˜</label>
                                                    <input type="text" value="${field.options ? field.options.join(', ') : ''}" onchange="updateFieldProperty('${sectionKey}', ${field.id}, 'options', this.value)" placeholder="ì˜µì…˜1,ì˜µì…˜2,ì˜µì…˜3">
                                                </div>
                                                <div class="field-prop required-field-prop">
                                                    <label>í•„ìˆ˜ ì—¬ë¶€</label>
                                                    <select onchange="updateFieldProperty('${sectionKey}', ${field.id}, 'required', this.value === 'required')">
                                                        <option value="optional" ${!field.required ? 'selected' : ''}>í•„ìˆ˜ ì•„ë‹˜</option>
                                                        <option value="required" ${field.required ? 'selected' : ''}>í•„ìˆ˜</option>
                                                    </select>
                                                </div>
                                            </div>
                                            <div class="field-actions">
                                                <button class="btn-delete-icon" onclick="removeField('${sectionKey}', ${field.id})" title="ì‚­ì œ">
                                                    <img src="/images/trash.png" alt="ì‚­ì œ" style="width: 20px; height: 20px;">
                                                </button>
                                            </div>
                                        </div>
                                    `).join('')
                                }
                            </div>        
                            </div>
                        </div>
                    </div>
                `;
                container.innerHTML += sectionHtml;
            });
        }

        // Update statistics
        function updateStats() {
            const totalSections = Object.keys(fieldConfigs).length;
            const totalFields = Object.values(fieldConfigs).reduce((sum, fields) => {
                const editableFields = fields.filter(field => !field.readonly);
                return sum + editableFields.length;
            }, 0);
            const activeSections = Object.values(fieldConfigs).filter(fields => {
                const editableFields = fields.filter(field => !field.readonly);
                return editableFields.length > 0;
            }).length;
            
            document.getElementById('totalSections').textContent = totalSections;
            document.getElementById('totalFields').textContent = totalFields;
            document.getElementById('activeSections').textContent = activeSections;
        }

        async function loadFieldConfigs() {
            try {
                const response = await fetch('/api/admin/field-configs');
                const data = await response.json();
                
                if (data.success) {
                    fieldConfigs = data.fieldConfigs;
                    cleanupFieldConfigs();
                    return true;
                } else {
                    console.error('Failed to load field configs:', data.error);
                    return false;
                }
            } catch (error) {
                console.error('Error loading field configs:', error);
                return false;
            }
        }
        
        function cleanupFieldConfigs() {
            let cleaned = false;
            
            if (!fieldConfigs || typeof fieldConfigs !== 'object') {
                console.error('âŒ Invalid fieldConfigs structure');
                return;
            }
            
            Object.keys(fieldConfigs).forEach(section => {
                if (!Array.isArray(fieldConfigs[section])) {
                    console.error(`âŒ Invalid section: ${section}`);
                    return;
                }
                
                fieldConfigs[section].forEach((field, index) => {
                    if (!field) return;
                    if (!field.referenceId) {
                        const maxReferenceId = Math.max(10000, ...fieldConfigs[section].filter(f => f && f.referenceId).map(f => f.referenceId));
                        field.referenceId = maxReferenceId + index + 1;
                        console.warn(`âš ï¸ Auto-assigned referenceId ${field.referenceId} to field: ${field.name} (${section})`);
                        cleaned = true;
                    }
                });
                
                let hasTimestampIds = fieldConfigs[section].some(f => f && f.id > 1000000000);
                if (hasTimestampIds) {
                    console.warn(`âš ï¸ Normalizing timestamp IDs in ${section}`);
                    fieldConfigs[section].forEach((field, index) => {
                        if (!field) return;
                        const oldId = field.id;
                        field.id = index + 1;
                        if (field.codebeamerId && field.codebeamerId.startsWith('field_')) {
                            field.codebeamerId = `custom_field_${field.id}`;
                        }
                        console.log(`  â†’ Normalized field "${field.name}": ${oldId} â†’ ${field.id}`);
                    });
                    cleaned = true;
                }
                
                fieldConfigs[section].forEach(field => {
                    if (!field) return;
                    if (field.type !== 'selector' && field.options) {
                        console.warn(`âš ï¸ Removing options from non-selector field: ${field.name} (${section})`);
                        delete field.options;
                        cleaned = true;
                    }
                    if (field.type === 'selector' && !field.options) {
                        console.log(`âœ“ Adding empty options to selector field: ${field.name} (${section})`);
                        field.options = [];
                        cleaned = true;
                    }
                    if (field.options && Array.isArray(field.options)) {
                        const originalLength = field.options.length;
                        field.options = field.options.filter(opt => opt && opt.trim() !== '');
                        if (field.options.length === 0 && field.type !== 'selector') {
                            console.warn(`âš ï¸ Removing empty options array from ${field.name} (${section})`);
                            delete field.options;
                            cleaned = true;
                        } else if (originalLength !== field.options.length) {
                            cleaned = true;
                        }
                    }
                });
            });
            
            if (cleaned) {
                console.log('ğŸ§¹ Cleaned up field configurations - saving...');
                saveFieldConfigs();
            }
        }

        // Save field configurations
        async function saveFieldConfigs() {
            try {
                console.log('ğŸ’¾ Saving field configs to server...');
                console.log('  - Sections:', Object.keys(fieldConfigs));
                console.log('  - Tracker IDs:', selectedTrackers);
                
                const saveData = {
                    fieldConfigs: fieldConfigs,
                    trackerIds: selectedTrackers
                };
                
                const response = await fetch('/api/admin/field-configs', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(saveData)
                });
                
                const data = await response.json();
                
                if (data.success) {
                    console.log('âœ“ Field configs saved successfully');
                    return true;
                } else {
                    console.error('âœ— Failed to save field configs:', data.error);
                    alert('ì„¤ì • ì €ì¥ ì‹¤íŒ¨: ' + data.error);
                    return false;
                }
            } catch (error) {
                console.error('âœ— Error saving field configs:', error);
                alert('ì„¤ì • ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
                return false;
            }
        }

        // Save section mapping
        async function saveSectionMapping(section) {
            console.log(`Saving mapping for ${section}:`, fieldConfigs[section]);
            const saved = await saveFieldConfigs();
            
            if (saved) {
                const updateCodebeamer = confirm('Codebeamerì— ì„¤ì •ì„ ë™ê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?');
                if (updateCodebeamer) {
                    await updateCodebeamerConfiguration(section);
                } else {
                alert(`${section} í•„ë“œ ë§¤í•‘ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                }
            } else {
                alert('í•„ë“œ ë§¤í•‘ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // Update Codebeamer configuration
        async function updateCodebeamerConfiguration(section) {
            try {
                let trackerId = selectedTrackers[section];
                const projectId = document.getElementById('projectId').value;

                if (!projectId) {
                    alert('í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                    return;
                }

                if (!trackerId) {
                    alert('í•´ë‹¹ ì„¹ì…˜ì˜ íŠ¸ë˜ì»¤ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.\nìƒë‹¨ì˜ "íŠ¸ë˜ì»¤ ê´€ë¦¬"ì—ì„œ ìƒˆ íŠ¸ë˜ì»¤ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                    return;
                }

                const response = await fetch('/api/admin/update-codebeamer-config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        section: section,
                        fieldConfigs: fieldConfigs[section],
                        trackerId: trackerId,
                        projectId: projectId
                    })
                });

                const data = await response.json();

                if (data.success) {
                    alert(`${section} Codebeamer ì„¤ì •ì´ ì„±ê³µì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤!\níŠ¸ë˜ì»¤: ${data.trackerId}\ní•„ë“œ ìˆ˜: ${data.fieldCount}`);
                } else {
                    alert(`Codebeamer ì„¤ì • ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ${data.error}`);
                }
            } catch (error) {
                console.error('Error updating Codebeamer configuration:', error);
                alert('Codebeamer ì„¤ì • ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // Test section mapping
        async function testSectionMapping(section) {
            console.log(`Testing mapping for ${section}:`, fieldConfigs[section]);
            
            let trackerId = selectedTrackers[section];
            const projectId = document.getElementById('projectId').value;
            
            if (!projectId) {
                alert('í”„ë¡œì íŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            if (!trackerId) {
                alert('í•´ë‹¹ ì„¹ì…˜ì˜ íŠ¸ë˜ì»¤ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.\nìƒë‹¨ì˜ "íŠ¸ë˜ì»¤ ê´€ë¦¬"ì—ì„œ ìƒˆ íŠ¸ë˜ì»¤ë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                return;
            }
            
            try {
                const response = await fetch('/api/admin/test-field-mapping', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        section: section,
                        fieldConfigs: fieldConfigs[section],
                        trackerId: trackerId
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    alert(`${section} í•„ë“œ ë§¤í•‘ í…ŒìŠ¤íŠ¸ê°€ ì„±ê³µí–ˆìŠµë‹ˆë‹¤.\níŠ¸ë˜ì»¤: ${data.trackerName}\ní•„ë“œ ìˆ˜: ${data.fieldCount}`);
                } else {
                    alert(`í•„ë“œ ë§¤í•‘ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ${data.error}`);
                }
            } catch (error) {
                console.error('Error testing field mapping:', error);
                alert('í•„ë“œ ë§¤í•‘ í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // Show add field form for specific section
        function showAddFieldForm(section) {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>ìƒˆ í•„ë“œ ì¶”ê°€ - ${getSectionName(section)}</h3>
                        <button class="modal-close" onclick="closeModal()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="field-type-selector">
                            <button class="field-type-btn active" data-type="string">ğŸ“ ë¬¸ìì—´</button>
                            <button class="field-type-btn" data-type="number">ğŸ”¢ ìˆ«ì</button>
                            <button class="field-type-btn" data-type="calendar">ğŸ“… ë‚ ì§œ</button>
                            <button class="field-type-btn" data-type="textarea">ğŸ“„ í…ìŠ¤íŠ¸ ì˜ì—­</button>
                            <button class="field-type-btn" data-type="selector">ğŸ“‹ ì„ íƒ</button>
                        </div>
                        
                        <div class="field-config-form">
                            <div class="field-config-row">
                                <span class="field-label">í•„ë“œëª…</span>
                                <input type="text" id="newFieldName" placeholder="í•„ë“œëª…ì„ ì…ë ¥í•˜ì„¸ìš”">
                            </div>
                            
                            <div class="field-config-row" id="newSelectorOptionsRow" style="display: none;">
                                <span class="field-label">ì„ íƒ ì˜µì…˜</span>
                                <input type="text" id="newFieldOptions" placeholder="ì˜µì…˜1,ì˜µì…˜2,ì˜µì…˜3 (ì‰¼í‘œë¡œ êµ¬ë¶„)">
                            </div>
                            
                            <div class="field-config-row">
                                <span class="field-label">í•„ìˆ˜ ì—¬ë¶€</span>
                                <select id="newFieldRequired">
                                    <option value="optional">í•„ìˆ˜ ì•„ë‹˜</option>
                                    <option value="required">í•„ìˆ˜</option>
                                </select>
                            </div>
                            
                            
                            
                            <div class="field-preview">
                                <h5>ë¯¸ë¦¬ë³´ê¸°</h5>
                                <div id="newFieldPreview"></div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn-admin btn-primary" onclick="addFieldToSection('${section}')">ì¶”ê°€</button>
                        <button class="btn-admin btn-secondary" onclick="closeModal()">ì·¨ì†Œ</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            initializeModalFieldTypeSelector();
            previewNewField();
        }

        // Get section name by key
        function getSectionName(sectionKey) {
            const names = {
                'weekly-reports': 'ì£¼ê°„ë³´ê³ ê´€ë¦¬',
                'travel-reports': 'ì¶œì¥ë³´ê³ ê´€ë¦¬',
                'hardware-management': 'HW/SW ë²„ì „ê´€ë¦¬',
                'equipment-management': 'ì¥ë¹„ê´€ë¦¬',
                'external-training': 'ì™¸ë¶€êµìœ¡ê´€ë¦¬'
            };
            return names[sectionKey] || sectionKey;
        }

        // Close modal
        function closeModal() {
            const modal = document.querySelector('.modal-overlay');
            if (modal) {
                modal.remove();
            }
        }

        // Initialize modal field type selector
        function initializeModalFieldTypeSelector() {
            const typeButtons = document.querySelectorAll('.modal-overlay .field-type-btn');
            typeButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    typeButtons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    updateModalFieldConfigForm(this.dataset.type);
                });
            });
        }

        // Update modal field configuration form
        function updateModalFieldConfigForm(type) {
            const selectorOptionsRow = document.getElementById('newSelectorOptionsRow');
            if (type === 'selector') {
                selectorOptionsRow.style.display = 'flex';
            } else {
                selectorOptionsRow.style.display = 'none';
            }
            previewNewField();
        }

        // Preview new field
        function previewNewField() {
            const type = document.querySelector('.modal-overlay .field-type-btn.active').dataset.type;
            const name = document.getElementById('newFieldName').value || 'ìƒ˜í”Œ í•„ë“œ';
            const required = document.getElementById('newFieldRequired').value === 'required';
            const options = document.getElementById('newFieldOptions').value;
            
            const preview = document.getElementById('newFieldPreview');
            let html = `<label>${name}${required ? ' *' : ''}</label>`;
            
            if (type === 'selector' && options) {
                const optionList = options.split(',').map(opt => opt.trim());
                html += `<select>`;
                html += '<option value="">ì„ íƒí•˜ì„¸ìš”</option>';
                optionList.forEach(option => {
                    html += `<option value="${option}">${option}</option>`;
                });
                html += '</select>';
            } else if (type === 'textarea') {
                html += `<textarea placeholder="${fieldTypes[type].name} ì…ë ¥" rows="4"></textarea>`;
            } else {
                const inputType = fieldTypes[type].inputType;
                html += `<input type="${inputType}" placeholder="${fieldTypes[type].name} ì…ë ¥">`;
            }
            
            preview.innerHTML = html;
        }

        // Add field to specific section
        async function addFieldToSection(section) {
            const name = document.getElementById('newFieldName').value;
            const type = document.querySelector('.modal-overlay .field-type-btn.active').dataset.type;
            const required = document.getElementById('newFieldRequired').value === 'required';
            const options = document.getElementById('newFieldOptions').value;
            
            if (!name) {
                alert('í•„ë“œëª…ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.');
                return;
            }
            
            if (type === 'selector' && !options) {
                alert('ì„ íƒ í•„ë“œì˜ ê²½ìš° ì˜µì…˜ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            const maxId = Math.max(0, ...fieldConfigs[section].map(f => f.id));
            const newId = maxId + 1;
            
            const maxReferenceId = Math.max(10000, ...fieldConfigs[section].filter(f => f.referenceId).map(f => f.referenceId));
            const newReferenceId = maxReferenceId + 1;
            
            const fieldConfig = {
                id: newId,
                name: name,
                codebeamerId: `custom_field_${newId}`,
                type: type,
                required: required,
                readonly: false,
                referenceId: newReferenceId
            };
            
            if (type === 'selector') {
                fieldConfig.options = options ? options.split(',').map(opt => opt.trim()).filter(opt => opt !== '') : [];
            }
            
            console.log(`âœ“ Created field with ID ${newId}, referenceId ${newReferenceId} for ${section}`);
            
            fieldConfigs[section].push(fieldConfig);
            const saved = await saveFieldConfigs();
            
            if (saved) {
                renderManagementSections();
                populateTrackerSelectors();
                updateStats();
                closeModal();
                alert('í•„ë“œê°€ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.');
            } else {
                alert('í•„ë“œ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // Update field property
        async function updateFieldProperty(section, fieldId, property, value) {
            const field = fieldConfigs[section].find(f => f.id === fieldId);
            if (field) {
                if (property === 'options') {
                    field[property] = value ? value.split(',').map(opt => opt.trim()).filter(opt => opt !== '') : [];
                } else {
                    field[property] = value;
                }
                
                if (property === 'type') {
                    const optionsField = document.getElementById(`options-${fieldId}`);
                    if (optionsField) {
                        optionsField.style.display = value === 'selector' ? 'flex' : 'none';
                    }
                    
                    if (value === 'selector' && !field.options) {
                        field.options = [];
                    } else if (value !== 'selector' && field.options) {
                        delete field.options;
                        console.log(`Cleaned up options from field ${field.name} (changed to ${value})`);
                    }
                }
                
                const saved = await saveFieldConfigs();
                if (!saved) {
                    alert('í•„ë“œ ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                }
            }
        }

        // Save all mappings at once
        async function saveAllMappings() {
            try {
                const saved = await saveFieldConfigs();
                
                if (saved) {
                    const updateCodebeamer = confirm('ëª¨ë“  ì„¤ì •ì„ Codebeamerì— ë™ê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?');
                    if (updateCodebeamer) {
                        await updateAllCodebeamerConfigurations();
                    } else {
                    alert('ëª¨ë“  í•„ë“œ ë§¤í•‘ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
                    }
                    console.log('All field configs saved:', fieldConfigs);
                } else {
                    alert('í•„ë“œ ë§¤í•‘ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                console.error('Error saving all mappings:', error);
                alert('ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        }

        // Update all Codebeamer configurations
        async function updateAllCodebeamerConfigurations() {
            const sections = Object.keys(fieldConfigs);
            let successCount = 0;
            let errorCount = 0;
            const errors = [];

            for (const section of sections) {
                if (fieldConfigs[section].length > 0) {
                    try {
                        await updateCodebeamerConfiguration(section);
                        successCount++;
                    } catch (error) {
                        errorCount++;
                        errors.push(`${section}: ${error.message}`);
                    }
                }
            }

            if (errorCount === 0) {
                alert(`ëª¨ë“  Codebeamer ì„¤ì •ì´ ì„±ê³µì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤!\nì„±ê³µ: ${successCount}ê°œ ì„¹ì…˜`);
            } else {
                alert(`Codebeamer ì„¤ì • ì—…ë°ì´íŠ¸ ì™„ë£Œ\nì„±ê³µ: ${successCount}ê°œ, ì‹¤íŒ¨: ${errorCount}ê°œ\n\nì‹¤íŒ¨í•œ ì„¹ì…˜:\n${errors.join('\n')}`);
            }
        }

    </script>
</body>
</html>
